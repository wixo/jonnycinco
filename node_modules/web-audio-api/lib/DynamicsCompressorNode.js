var  _ = require('underscore')
  , math = require('mathjs')
  , constants = require('./constants')
  , AudioNode = require('./AudioNode')
  , AudioParam = require('./AudioParam')
  , AudioBuffer = require('audiobuffer')
  , inherits = require('util').inherits
  , readOnlyAttr = require('./utils').readOnlyAttr

var DynamicsCompressorNode = module.exports = function(context) {
  AudioNode.call(this, context, 1, 1)
  this.channelCountMode = 'explicit'
  this.channelCount = 2
  this.channelInterpretation = 'speakers'

  readOnlyAttr(this, 'threshold', new AudioParam(this.context, -24, 'k'))
  readOnlyAttr(this, 'knee', new AudioParam(this.context, 30, 'k'))
  readOnlyAttr(this, 'ratio', new AudioParam(this.context, 12, 'k'))
  readOnlyAttr(this, 'attack', new AudioParam(this.context, 0.003, 'k'))
  readOnlyAttr(this, 'release', new AudioParam(this.context, 0.250, 'k'))

  // TODO
  Object.defineProperty(this, 'reduction', {
    get: function() {

    }
  })

  this._dsp = this._dspZeros
}
inherits(DynamicsCompressorNode, AudioNode)

_.extend(DynamicsCompressorNode.prototype, {

  // Implementation based on :
  // "Investigation in Dynamic Range Compression" - MSc Project
  // Copyright 2009, Michael Massberg
  // michael@massberg.org
  _tick: function() {
    AudioNode.prototype._tick.apply(this, arguments)
    var inBuff = this._inputs[0]._tick()
      , outBuff = new AudioBuffer(inBuff.numberOfChannels, constants.BLOCK_SIZE, this.context.sampleRate)
      , attack = this.attack.value
      , release = this.release.value
      , ch, chArray, logIn, gain

    for (ch = 0; ch < inBuff.numberOfChannels; ch++) {
      chArray = _.toArray(inBuff.getChannelData(ch))

      // Get the logarithm of the input
      logIn = math.select(chArray)
        .abs()
        .map(function(elem) { return Math.max(elem, 1e-6) })
        .log10()
        .emultiply(20)
        .done()

      // ???
      gain = this.computeGain(logIn)

      gain = this.peakDetect(
        math.emultiply(gain, -1),
        this.context.sampleRate, attack, release
      )

      // Calculate the gain and apply it
      gain = math.epow(10, math.edivide(gain, -20))
      outBuff.getChannelData(ch).set(math.emultiply(chArray, gain))
    }

    return outBuff
  },

  // Compressor gain computer - generates a logarithmic
  // control voltage for the given logarithmic input level
  //
  // Parameters
  //   logIn: logarithmic input level
  //
  // Returns
  //   logarithmic control voltage
  computeGain: function(logIn) {

    var overshoot = math.subtract(logIn, this.threshold.value)
      , knee = this.knee.value
      , slope = 1 / this.ratio.value - 1 // Feed-forward topology
      , rectified

    // Soft half-wave rectifier
    if (knee > 0) {
      var w2 = knee / 2
        , a = 1 / (knee * knee)
        , inTransition = math.select(overshoot)
          .abs()
          .smaller(w2)
          .map(function(elem) { return elem ? 1 : 0 }).done()

      rectified = math.select(overshoot)
        .add(w2)
        .epow(2)
        .emultiply(a)
        .emultiply(inTransition).done()

      rectified = math.select(inTransition)
        .emultiply(-1)
        .add(1)
        .emultiply(math.map(overshoot, function(elem) { return math.max(elem, 0) }))
        .add(rectified).done()

    // Hard half-wave rectifier
    } else rectified = math.max(overshoot, 0)
    return math.emultiply(rectified, slope)
  },

  // Analog peak detector with an ideal diode and
  // different time constants for attack and release.
  //
  // Parameters
  // x: input signal
  //
  // Returns
  // y: detector output
  peakDetect: function(inArray) {
    var sampleRate = this.context.sampleRate
      , attack = this.attack.value
      , release = this.release.value
      , outArray = new Array(inArray.length)
      , taufs, alphaAtt, alphaRel, i, length, state

    taufs = attack * sampleRate
    if (attack > 0) alphaAtt = Math.exp(-1 / taufs)
    else alphaAtt = 0

    taufs = release * sampleRate
    if (release > 0) alphaRel = Math.exp(-1 / taufs)
    else alphaRel = 0

    state = 0
    for (i = 0, length = inArray.length; i < length; i++) {
      state = alphaRel * state + (1 - alphaAtt) * Math.max(inArray[i] - state, 0)
      outArray[i] = state
    }

    return outArray
  }

})
